-- .dockerignore
-- .env
-- .vscode
|   | -- launch.json
|   | -- tasks.json
-- api
|   | -- controllers
|  |   | -- storesController.js
|   | -- helper
|  |   | -- blockResources.js
|  |   | -- cleanPrice.js
|  |   | -- click.js
|  |   | -- delay.js
|  |   | -- descriptionBuilder.js
|  |   | -- getVariants.js
|  |   | -- htmlSelector.js
|  |   | -- packages.js
|  |   | -- selector.js
|  |   | -- validate.js
|   | -- models
|  |   | -- data
|  |      | -- browserleaks.json
|  |      | -- defacto.json
|  |      | -- github.json
|  |      | -- hm.json
|  |      | -- koton.json
|  |      | -- lcwaikiki.json
|  |      | -- mango.json
|  |      | -- sannysoft.json
|  |      | -- trackip.json
|  |      | -- trendyol.json
|  |      | -- zara.json
|   | -- routes
|      | -- storeRoute.js
-- docker-compose.yml
-- Dockerfile
-- index.js
-- localStorage.json
-- notes.txt
-- package.json
-- store.json
-- temp.json
/* ./api/controllers/storesController.js */
'use strict'; /* * Purpose : Website Search API * Package : Controller * Developed By : Tishko Rasoul (tishko.rasoul@gmail.com) */ const { puppeteer, scrollToBottom, validationResult, fs, Xvfb, stealth, useProxy, elementSelector, delay, isValidStore, blockResources, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, htmlSelector, } = require('../helper/packages.js'); let storesController = { search }; async function search(req, res) { var browser; /* To Check Validation json */ let errors = validationResult(req); if (!errors.isEmpty()) { return res.status(500).json({ Message: errors.array()[0].msg, }); } let handle = req.body.handle; console.log('\x1b[34m%s\x1b[0m', handle); var match = await handle.match( '^((http[s]?|ftp)://)?/?([^/.]+.)*?([^/.]+.[^:/s.]{1,3}(.[^:/s.]{1,2})?(:d+)?)($|/)([^#?s]+)?(.*?)?(#[w-]+)?$' ); let store = await match[4].replace(/\..+/g, ''); if (!(await isValidStore(store))) { console.log('\x1b[33m%s\x1b[0m', handle); return res.status(500).json({ data: {}, Message: `${store} is not supported!`, }); } const data = await require('../models/data/' + store); const userAgents = [ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:70.0) Gecko/20100101 Firefox/70.0', ]; //const userAgent = userAgents[Math.floor(Math.random() * userAgents.length)] const userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'; //const userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" const xvfb = new Xvfb({ silent: true, xvfb_args: ['-screen', '0', '1366x768x24', '-ac'], }); var args = []; args.push(`--no-sandbox`); args.push(`--disable-setuid-sandbox`); args.push(`--window-size=1366x768`); args.push(`--blink-settings=imagesEnabled=true`); args.push(`--disable-translate`); args.push(`--window-position=0,0`); args.push('--hide-scrollbars'); args.push('--mute-audio'); args.push(`--disable-speech-api`); args.push(`--user-agent=${userAgent}`); args.push(`--disable-web-security`); if (!data.isHeadless) { await xvfb.startSync(); args.push('--use-fake-device-for-media-stream'); args.push('--display=' + xvfb._display); } /* Initialize Browser */ try { // Enable stealth plugin if (!data.isHeadless) { puppeteer.use( stealth({ enabledEvasions: new Set([ /* evasions for headless only 'chrome.app', 'chrome.csi', 'chrome.loadTimes', 'chrome.runtime', 'navigator.permissions', 'navigator.plugins', 'window.outerdimensions' */ //launch args (the webdriver fix is very much needed depending on how you launch chrome, just the method changed in v89) and sourceurl 'defaultArgs', // appears to be necessary to prevent iframe issues? https://github.com/puppeteer/puppeteer/issues/1106 'iframe.contentWindow', // necessary if running chromium instad of chrome 'media.codecs', // Doesn't appear to be necessary with chrome version > 89? 'navigator.webdriver', // Strips puppeteer/CDP artifacts from stacktrace 'sourceurl', /* thou shall not lie about thou hardware stack 'user-agent-override', // better off using this plugin manually than the default MSFT UA imo 'webgl.vendor', // Try and use common hardware instead */ ]), }) ); } else { stealth().enabledEvasions.delete('user-agent-override'); stealth().enabledEvasions.delete('webgl.vendor'); puppeteer.use(stealth()); } /* Launch Browser */ browser = await puppeteer.launch({ headless: data.isHeadless ? 'new' : false, executablePath: '/usr/bin/chromium-browser', args: args, slowMo: 0, }); // First page const page = (await browser.pages())[0]; // User agent override await require('puppeteer-extra-plugin-stealth/evasions/user-agent-override')({ userAgent: userAgent, locale: 'en-US,en', maskLinux: true, }).onPageCreated(page); //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.hardwareConcurrency`)(8).onPageCreated(page) //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.vendor`)({ vendor: 'Google Inc.' }).onPageCreated(page) // WebGL Vendor override await require(`puppeteer-extra-plugin-stealth/evasions/webgl.vendor`)({ vendor: 'Google Inc. (Intel)', renderer: 'Intel, Intel(R) HD Graphics 4000 Direct3D11 vs_5_0 ps_5_0, D3D11', }).onPageCreated(page); // Randomize proxy var proxies = data.proxies[Math.floor(Math.random() * data.proxies.length)]; if (data.debug && proxies) { console.log(proxies); // Use Proxy await useProxy(page, proxies); } //Randomize viewport size await page.setViewport({ width: 1366 + Math.floor(Math.random() * 100), height: 768 + Math.floor(Math.random() * 100), deviceScaleFactor: 1, hasTouch: false, isLandscape: false, isMobile: false, }); await page.setJavaScriptEnabled(true); await page.setDefaultNavigationTimeout(0); //await page.setUserAgent(userAgent); // Saved cookies reading const cookies = fs.readFileSync('cookies.json', 'utf8'); const deserializedCookies = JSON.parse(cookies); await page.setCookie(...deserializedCookies); //await page.emulateTimezone('Asia/Baghdad'); await page.setRequestInterception(true); //Block unnecessary resource types and urls await blockResources(page, data); // Go to page await page.goto(req.body.handle, { waitUntil: data.waitUntil, timeout: 0, }); // Randomly mouse movement to bypass detections await page.mouse.move(100, Math.floor(Math.random() * 100)); await page.mouse.move(200, Math.floor(Math.random() * 100)); // Save cookies const saveCookies = await page.cookies(); await fs.promises.writeFile('./cookies.json', JSON.stringify(saveCookies, null, 2)); // Scroll to bottom if (data.scrollToBottom) await page.evaluate(scrollToBottom, { frequency: 200, timing: 0 }); if (data.debug) await delay(8000); // debug if (data.debug) { // fs.writeFileSync('debug/docs/' + store + '.html', await page.evaluate(() => { // return document.querySelectorAll("html")[0].outerHTML // }), { // encoding: 'utf8', // flag: 'w' // }) // console.log(await page.evaluate(() => { // var arr = [] // arr.push(navigator.webdriver) // arr.push(navigator.language) // arr.push(navigator.deviceMemory) // arr.push(navigator.hardwareConcurrency) // arr.push(navigator.platform) // arr.push(window.screen.width) // arr.push(window.screen.height) // return arr // })) await page.screenshot({ path: 'debug/screenshoots/' + store + '.png', fullPage: true, }); } // Wait for Selector if (data.container) { // Correct the method to 'startsWith' if (data.container.startsWith('//') || data.container.startsWith('(//') || data.container.startsWith('((//')) { await page.waitForXPath(data.container, { timeout: 30000, }); } else { await page.waitForSelector(data.container, { timeout: 30000, }); } } else { throw new Error('Container is empty, please check your selector'); } const response = {}; response.handle = req.body.handle; const title = await elementSelector( page, data.title.selectors, data.title.attribute, data.title.regex, data.title.groups, true, data.title.valueToReplace ); if (Array.isArray(title)) { response.title = title.join(' '); } else { response.title = title || ''; } let descriptions = []; if (data.descriptions.selectors.length) { descriptions = await elementSelector( page, data.descriptions.selectors, data.descriptions.attribute, data.descriptions.regex, data.descriptions.groups, true, data.descriptions.valueToReplace ); } let htmlDescriptions = []; if (data.htmlDescriptions.selectors.length) { htmlDescriptions = await htmlSelector( page, data.htmlDescriptions.selectors, true, data.htmlDescriptions.valueToReplace ); } let tempDescription; if (descriptions.length) { if (descriptions.length > 2) { if (htmlDescriptions.length) { tempDescription = '<ul><li>' + descriptions.join('</li><li>') + '</li></ul>'; } else { tempDescription = '<ul><li>' + descriptions.join('</li><li>') + '</li></ul></br>'; } } else { if (htmlDescriptions.length) { tempDescription = descriptions.join('</br>') + '</br></br>'; } else { tempDescription = descriptions.join('</br>'); } } } if (htmlDescriptions.length) { tempDescription += '<table><tbody>' + htmlDescriptions.join('</br>') + '</tbody></table>'; } const vendor = data.vendor.name || (await elementSelector( page, data.vendor, data.vendor.attribute, data.vendor.regex, data.vendor.groups, true, data.vendor.valueToReplace )); if (Array.isArray(vendor)) { response.vendor = vendor.join(' '); } else { response.vendor = vendor || ''; } const category = await elementSelector( page, data.category.selectors, data.category.attribute, data.category.regex, data.category.groups, true, data.category.valueToReplace ); if (Array.isArray(category)) { response.category = category.join(' '); } else { response.category = category.trim() || ''; } // if (data.option3.selectors.length) { // response.variants = await GetOption3AndOption2AndOption1(page, data); // } else if (data.option2.selectors.length) { // response.variants = await GetOption2AndOption1(page, data, null, null, null, []); // } else { // } const option3AndOption2AndOption1 = await GetOption3AndOption2AndOption1(page, data); const option2AndOption1 = await GetOption2AndOption1(page, data, null, null, null, []); const option1 = await GetOption1(page, data, null, null, null, null, null, null, []); response.variants = option3AndOption2AndOption1.length ? option3AndOption2AndOption1 : option2AndOption1.length ? option2AndOption1 : option1.length ? option1 : []; response.message = 'success'; console.log('\x1b[32m%s\x1b[0m', 'Succeed response'); //green return res.status(200).json(response); } catch (e) { console.log('\x1b[31m%s\x1b[0m', e.message); if (e.message.includes('Waiting failed')) { return res.status(500).json({ message: e.message, }); } else if (e.message.includes('Timeout exceeded while waiting for event')) { return res.status(500).json({ message: e.message, }); } else { console.log('err', e); return res.status(500).json({ message: 'Some error occured Or data not found, please try again.', }); } } finally { if (!data.isHeadless) { xvfb.stopSync(); } browser.close(); } } module.exports = storesController;

/* ./api/helper/descriptionBuilder.js */
// Function to handle the concatenation of descriptions function concatenateDescriptions(descriptions, isHTML = false) { const separator = isHTML ? '</br></br>' : '</br>'; return descriptions.join(separator); } // Function to create an HTML list from an array function createList(items) { const listItems = items.map((item) => `<li>${item}</li>`).join(''); return `<ul>${listItems}</ul>`; } // Function to create an HTML table from an array function createTable(items) { const tableRows = items.map((item) => `<tr><td>${item}</td></tr>`).join(''); return `<table><tbody>${tableRows}</tbody></table>`; } async function processDescriptions(page, data) { let tempDescription = ''; // Process normal descriptions let descriptions = []; if (data.descriptions.selectors.length) { descriptions = await elementSelector( page, data.descriptions.selectors, data.descriptions.attribute, data.descriptions.regex, data.descriptions.groups, true, data.descriptions.valueToReplace ); } // Process HTML descriptions let htmlDescriptions = []; if (data.htmlDescriptions.selectors.length) { htmlDescriptions = await htmlSelector( page, data.htmlDescriptions.selectors, true, data.htmlDescriptions.valueToReplace ); } // Combine descriptions if (descriptions.length) { tempDescription += descriptions.length > 2 ? createList(descriptions) : concatenateDescriptions(descriptions, htmlDescriptions.length > 0); } // Append HTML descriptions in a table if (htmlDescriptions.length) { tempDescription += createTable(htmlDescriptions); } return tempDescription; } module.exports = { processDescriptions };

/* ./api/helper/htmlSelector.js */
async function mainSelector(page, selector) { try { return await page.evaluate( ({ selector }) => { // Define cleanHtml function inside page.evaluate function cleanHtml(html) { const doc = new DOMParser().parseFromString(html, 'text/html'); // Define an array of tags to remove const tagsToRemove = ['button', 'video', 'source', 'style', 'img']; // Define an array of tags to exclude const excludedTags = ['table', 'tr', 'td', 'th', 'thead', 'tbody', 'tfoot']; // Remove specified tags tagsToRemove.forEach((tag) => { const elements = doc.querySelectorAll(tag); elements.forEach((el) => el.parentNode.removeChild(el)); }); // Remove comments const allNodes = doc.body.childNodes; for (let i = allNodes.length - 1; i >= 0; i--) { if (allNodes[i].nodeType === 8) { // Node type 8 is for comments allNodes[i].parentNode.removeChild(allNodes[i]); } } const allElements = doc.querySelectorAll('*'); for (let el of allElements) { // if (!excludedTags.includes(el.tagName.toLowerCase())) { // while (el.attributes.length > 0) el.removeAttribute(el.attributes[0].name); // } // Remove all attributes except for table-related elements while (el.attributes.length > 0) el.removeAttribute(el.attributes[0].name); // Remove empty elements except for table-related elements if (el.innerHTML.trim() === '' && !excludedTags.includes(el.tagName.toLowerCase())) { el.parentNode.removeChild(el); } } // Get the HTML as a string and remove tabs, line breaks, and new lines let cleanedHtml = doc.body.innerHTML; cleanedHtml = cleanedHtml.replace(/[\t\n\r]+/g, ' '); return cleanedHtml; // Return the cleaned HTML } const isXPathSelector = selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//'); let elements; if (isXPathSelector) { const result = document.evaluate(selector, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); elements = []; for (let i = 0; i < result.snapshotLength; i++) { elements.push(result.snapshotItem(i)); } } else { elements = Array.from(document.querySelectorAll(selector)); } return elements.map((el) => cleanHtml(el.outerHTML)).filter((html) => html.trim() !== ''); }, { selector } ); } catch (error) { console.log('\x1b[31m%s\x1b[0m', `Error with selector ${selector} > ${error}`); return []; } } function replaceValues(value, replacements) { replacements.forEach((replacement) => { if (replacement.value) { value = value.replace(new RegExp(replacement.value, 'gi'), replacement.replaceWith); } }); return value.trim(); } async function htmlSelector(page, selectors, queryAll, valueToReplace) { if (!Array.isArray(selectors)) { throw new Error('selectors must be an array'); } if (valueToReplace && !Array.isArray(valueToReplace)) { throw new Error('valueToReplace must be an array of replacement rules'); } let selectedValues = []; for (const selector of selectors) { const elements = await mainSelector(page, selector); if (elements.length === 0) { console.log('\x1b[90m%s\x1b[0m', `Error selector "${selector}" returned 0 elements`); continue; } for (const elementValue of elements) { let value = elementValue; if (valueToReplace) { value = replaceValues(value, valueToReplace); } if (value) selectedValues.push(value); } if (!queryAll && selectedValues.length) { break; } } return selectedValues; } module.exports = { htmlSelector };
