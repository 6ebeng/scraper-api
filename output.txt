-- .dockerignore
-- .env
-- api
|   | -- controllers
|  |   | -- storesController.js
|   | -- helper
|  |   | -- blockResources.js
|  |   | -- bypassDetections.js
|  |   | -- bypassWebgl.js
|  |   | -- cleanPrice.js
|  |   | -- click.js
|  |   | -- delay.js
|  |   | -- getVariants.js
|  |   | -- packages.js
|  |   | -- selector.js
|  |   | -- validate.js
|   | -- models
|  |   | -- data
|  |      | -- browserleaks.json
|  |      | -- defacto.json
|  |      | -- github.json
|  |      | -- hm.json
|  |      | -- koton.json
|  |      | -- lcwaikiki.json
|  |      | -- mango.json
|  |      | -- sannysoft.json
|  |      | -- trackip.json
|  |      | -- trendyol.json
|  |      | -- zara.json
|   | -- routes
|      | -- storeRoute.js
-- docker-compose.yml
-- Dockerfile
-- index.js
-- localStorage.json
-- notes.txt
-- package.json
-- temp.json
/* ./api/controllers/storesController.js */
'use strict'; const e = require('express'); /* * Purpose : Website Search API * Package : Controller * Developed By : Tishko Rasoul (tishko.rasoul@gmail.com) */ const { puppeteer, scrollToBottom, validationResult, fs, Xvfb, stealth, useProxy, elementSelector, elementClick, delay, isValidStore, blockResources, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, } = require('../helper/packages.js'); // const bypass = require("../helper/bypassDetections.js"); // const bypassWebgl = require("../helper/bypassWebgl.js"); let storesController = { search }; async function search(req, res) { var browser; /* To Check Validation json */ let errors = validationResult(req); if (!errors.isEmpty()) { return res.status(500).json({ data: [], Message: errors.array()[0].msg, }); } let handle = req.body.handle; console.log('\x1b[34m%s\x1b[0m', handle); var match = await handle.match( '^((http[s]?|ftp)://)?/?([^/.]+.)*?([^/.]+.[^:/s.]{1,3}(.[^:/s.]{1,2})?(:d+)?)($|/)([^#?s]+)?(.*?)?(#[w-]+)?$' ); let store = await match[4].replace(/\..+/g, ''); if (!(await isValidStore(store))) { console.log('\x1b[33m%s\x1b[0m', handle); return res.status(500).json({ data: {}, Message: `${store} is not supported!`, }); } const data = await require('../models/data/' + store); const userAgents = [ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:70.0) Gecko/20100101 Firefox/70.0', ]; //const userAgent = userAgents[Math.floor(Math.random() * userAgents.length)] const userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'; //const userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" const xvfb = new Xvfb({ silent: true, xvfb_args: ['-screen', '0', '1366x768x24', '-ac'], }); var args = []; args.push(`--no-sandbox`); args.push(`--disable-setuid-sandbox`); args.push(`--window-size=1366x768`); args.push(`--blink-settings=imagesEnabled=true`); args.push(`--disable-translate`); args.push(`--window-position=0,0`); args.push('--hide-scrollbars'); args.push('--mute-audio'); args.push(`--disable-speech-api`); args.push(`--user-agent=${userAgent}`); args.push(`--disable-web-security`); if (!data.isHeadless) { await xvfb.startSync(); args.push('--use-fake-device-for-media-stream'); args.push('--display=' + xvfb._display); } /* Initialize Browser */ try { // Enable stealth plugin if (!data.isHeadless) { puppeteer.use( stealth({ enabledEvasions: new Set([]), }) ); } else { stealth().enabledEvasions.delete('user-agent-override'); stealth().enabledEvasions.delete('webgl.vendor'); puppeteer.use(stealth()); } /* Launch Browser */ browser = await puppeteer.launch({ headless: data.isHeadless ? 'new' : false, executablePath: '/usr/bin/chromium-browser', args: args, slowMo: 0, }); // First page const page = (await browser.pages())[0]; // User agent override await require('puppeteer-extra-plugin-stealth/evasions/user-agent-override')({ userAgent: userAgent, locale: 'en-US,en', maskLinux: true, }).onPageCreated(page); //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.hardwareConcurrency`)(8).onPageCreated(page) //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.vendor`)({ vendor: 'Google Inc.' }).onPageCreated(page) // WebGL Vendor override await require(`puppeteer-extra-plugin-stealth/evasions/webgl.vendor`)({ vendor: 'Google Inc. (Intel)', renderer: 'Intel, Intel(R) HD Graphics 4000 Direct3D11 vs_5_0 ps_5_0, D3D11', }).onPageCreated(page); //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.languages`)(['en-US', 'en']).onPageCreated(page) // Randomize proxy var proxies = data.proxies[Math.floor(Math.random() * data.proxies.length)]; if (data.debug && proxies) { console.log(proxies); // Use Proxy await useProxy(page, proxies); } //Randomize viewport size await page.setViewport({ width: 1366 + Math.floor(Math.random() * 100), height: 768 + Math.floor(Math.random() * 100), deviceScaleFactor: 1, hasTouch: false, isLandscape: false, isMobile: false, }); await page.setJavaScriptEnabled(true); await page.setDefaultNavigationTimeout(0); //await page.setUserAgent(userAgent); // Saved cookies reading const cookies = fs.readFileSync('cookies.json', 'utf8'); const deserializedCookies = JSON.parse(cookies); await page.setCookie(...deserializedCookies); //await page.emulateTimezone('Asia/Baghdad'); await page.setRequestInterception(true); //Block unnecessary resource types and urls await blockResources(page, data); // Go to page await page.goto(req.body.handle, { waitUntil: data.waitUntil, timeout: 0, }); // Print response headers while debugging if (data.debug) console.log(await response.headers()); // Randomly mouse movement to bypass detections await page.mouse.move(100, Math.floor(Math.random() * 100)); await page.mouse.move(200, Math.floor(Math.random() * 100)); // Save cookies const saveCookies = await page.cookies(); await fs.promises.writeFile('./cookies.json', JSON.stringify(saveCookies, null, 2)); // Scroll to bottom if (data.scrollToBottom) await page.evaluate(scrollToBottom, { frequency: 200, timing: 0 }); if (data.debug) await delay(8000); // debug if (data.debug) { await page.screenshot({ path: 'debug/screenshoots/' + store + '.png', fullPage: true, }); } // Wait for Response // we need to use waitForResponse because we are dealing with AJAX - no page navigation await page.waitForResponse((response) => { return response.status() === 200; }); // Wait for Selector await page.waitForSelector(data.container, { timeout: 30000, }); // InStock Sizes var InStockSizes = await elementSelector( page, data.inStockSizes.selector, data.inStockSizes.attribute || null, data.inStockSizes.regex || null, data.inStockSizes.groups || [], true ); const response = {}; response.handle = req.body.handle; response.title = await elementSelector( page, data.title.selector || null, data.title.attribute || null, data.title.regex || null, data.title.groups || [], false ); response.descriptions = (await elementSelector( page, data.descriptions.selector || null, data.descriptions.attribute || null, data.descriptions.regex || null, data.descriptions.groups || [], true )) || ''; response.vendor = (await elementSelector( page, data.vendor, data.vendor.attribute || null, data.vendor.regex || null, data.vendor.groups || [], false )) || ''; response.category = ( await elementSelector( page, data.category.selector || null, data.category.attribute || null, data.category.regex || null, data.category.groups || [], false ) ) .join(' ') .trim() || ''; response.variants = (await GetOption3AndOption2AndOption1(page, data)) || (await GetOption2AndOption1(page, data, null, null, null, null)) || (await GetOption1(page, data, null, null, null, null, null, null, null, null)) || []; response.message = 'success'; console.log('\x1b[32m%s\x1b[0m', 'Succeed response'); //green return res.status(200).json(response); } catch (e) { console.log('\x1b[31m%s\x1b[0m', e.message); if (e.message.includes('Waiting failed')) { return res.status(500).json({ message: e.message, }); } else if (e.message.includes('Timeout exceeded while waiting for event')) { return res.status(500).json({ message: e.message, }); } else { console.log('err', e); return res.status(500).json({ message: 'Some error occured Or data not found, please try again.', }); } } finally { if (!data.isHeadless) { xvfb.stopSync(); } browser.close(); } } module.exports = storesController;

/* ./api/helper/blockResources.js */
async function blockResources(page, data) { page.on("request", async (request) => { var resourceType; var url = true; // Block resource types for (let index = 0; index < data.blockResourceTypes.length; index++) { if (request.resourceType() === data.blockResourceTypes[index]) resourceType = true; } // Whitelist urls if (!resourceType) { for (let index = 0; index < data.whiteListUrls.length; index++) { if (request.url().includes(data.whiteListUrls[index])) url = null; } } // Block urls if (!url) { for (let index = 0; index < data.blockUrls.length; index++) { if (request.url().includes(data.blockUrls[index])) url = true; } } // Print blocked urls if (resourceType || url) { if (url) { //console.log(request.resourceType()); if (data.debug) console.log("\x1b[31m%s\x1b[0m", request.url()); } request.abort(); // Abort blocked urls } else { //console.log(request.resourceType()); if (data.debug) // Print unblocked urls console.log("\x1b[32m%s\x1b[0m", '"' + request.url() + '",'); request.continue(); // Continue unblocked urls } }); } module.exports = { blockResources };

/* ./api/helper/bypassDetections.js */
module.exports = async function bypassDetections(page){ await page.evaluateOnNewDocument(() => { // Object.defineProperty(navigator, "languages", { get: () => ['en-US', 'en', 'ku'] }); // Object.defineProperty(navigator, 'deviceMemory', { get: () => 8 }); // Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => 8 }); Object.defineProperty(navigator, 'platform', { get: () => 'Win32' }); //Object.defineProperty(navigator, 'plugins', {get: function() {return [1, 2, 3, 4, 5];}}); //detection expose // // Object.defineProperty(HTMLIFrameElement.prototype, 'contentWindow', {get: function() {return window}}); HM not work // window.chrome = { // runtime: true // }; // window.navigator.chrome = { // runtime: true, // }; // const getParameter = WebGLRenderingContext.getParameter; // WebGLRenderingContext.prototype.getParameter = function (parameter) { // // UNMASKED_VENDOR_WEBGL // if (parameter === 37445) { // return 'Intel Inc.'; // } // // UNMASKED_RENDERER_WEBGL // if (parameter === 37446) { // return 'Intel Iris OpenGL Engine'; // } // return getParameter(parameter); // }; // store the existing descriptor const elementDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight'); // redefine the property with a patched descriptor Object.defineProperty(HTMLDivElement.prototype, 'offsetHeight', { ...elementDescriptor, get: function () { if (this.id === 'modernizr') { return 1; } return elementDescriptor.get.apply(this); }, }); // (function () { var overwrite = function (name) { // const OLD = HTMLCanvasElement.prototype[name]; // Object.defineProperty(HTMLCanvasElement.prototype, name, { // "value": function () { // var shift = { // 'r': Math.floor(Math.random() * 10) - 5, // 'g': Math.floor(Math.random() * 10) - 5, // 'b': Math.floor(Math.random() * 10) - 5, // 'a': Math.floor(Math.random() * 10) - 5 // }; // var width = this.width, height = this.height, context = this.getContext("2d"); // var imageData = context.getImageData(0, 0, width, height); // for (var i = 0; i < height; i++) { // for (var j = 0; j < width; j++) { // var n = ((i * (width * 4)) + (j * 4)); // imageData.data[n + 0] = imageData.data[n + 0] + shift.r; // imageData.data[n + 1] = imageData.data[n + 1] + shift.g; // imageData.data[n + 2] = imageData.data[n + 2] + shift.b; // imageData.data[n + 3] = imageData.data[n + 3] + shift.a; // } // } // context.putImageData(imageData, 0, 0); // return OLD.apply(this, arguments); // } // }); // }; // overwrite('toBlob'); // overwrite('toDataURL'); // })(); }); // await page.evaluateOnNewDocument(() => { // //Pass notifications check // const originalQuery = window.navigator.permissions.query; // return window.navigator.permissions.query = (parameters) => ( // parameters.name === 'notifications' ? // Promise.resolve({ state: Notification.permission }) : // originalQuery(parameters) // ); // }); // await page.evaluateOnNewDocument(() => { // // Overwrite the `plugins` property to use a custom getter. // Object.defineProperty(navigator, 'plugins', { // // This just needs to have `length > 0` for the current test, // // but we could mock the plugins too if necessary. // get: () => [1, 2, 3, 4, 5], // }); // }); }

/* ./api/helper/bypassWebgl.js */
module.exports = async function bypassWebgl(page,userAgent,vendor){ // YOU NEED TO SET this._settings.device.userAgent AND vendor const WEBGL_RENDERERS_DESKTOP = ['ANGLE (NVIDIA Quadro 2000M Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (NVIDIA Quadro K420 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA Quadro 2000M Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA Quadro K2000M Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (Intel(R) HD Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Family Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 3800 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics 4000 Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (Intel(R) HD Graphics 4000 Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (AMD Radeon R9 200 Series Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (Intel(R) HD Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Family Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Family Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics 4000 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics 3000 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Mobile Intel(R) 4 Series Express Chipset Family Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G33/G31 Express Chipset Family Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (Intel(R) Graphics Media Accelerator 3150 Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (Intel(R) G41 Express Chipset Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 6150SE nForce 430 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics 4000)', 'ANGLE (Mobile Intel(R) 965 Express Chipset Family Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Family)', 'ANGLE (NVIDIA GeForce GTX 760 Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (NVIDIA GeForce GTX 760 Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (NVIDIA GeForce GTX 760 Direct3D11 vs_5_0 ps_5_0)', 'ANGLE (AMD Radeon HD 6310 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Graphics Media Accelerator 3600 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G33/G31 Express Chipset Family Direct3D9 vs_0_0 ps_2_0)', 'ANGLE (AMD Radeon HD 6320 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G33/G31 Express Chipset Family (Microsoft Corporation - WDDM 1.0) Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (Intel(R) G41 Express Chipset)', 'ANGLE (ATI Mobility Radeon HD 5470 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q45/Q43 Express Chipset Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 310M Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G41 Express Chipset Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (Mobile Intel(R) 45 Express Chipset Family (Microsoft Corporation - WDDM 1.1) Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 440 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 4300/4500 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7310 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics)', 'ANGLE (Intel(R) 4 Series Internal Chipset Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon(TM) HD 6480G Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 3200 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7800 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G41 Express Chipset (Microsoft Corporation - WDDM 1.1) Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 210 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 630 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7340 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) 82945G Express Chipset Family Direct3D9 vs_0_0 ps_2_0)', 'ANGLE (NVIDIA GeForce GT 430 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 7025 / NVIDIA nForce 630a Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q35 Express Chipset Family Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (Intel(R) HD Graphics 4600 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7520G Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD 760G (Microsoft Corporation WDDM 1.1) Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 220 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 9500 GT Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Family Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Graphics Media Accelerator HD Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 9800 GT Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q965/Q963 Express Chipset Family (Microsoft Corporation - WDDM 1.0) Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (NVIDIA GeForce GTX 550 Ti Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q965/Q963 Express Chipset Family Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (AMD M880G with ATI Mobility Radeon HD 4250 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GTX 650 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Mobility Radeon HD 5650 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 4200 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7700 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G33/G31 Express Chipset Family)', 'ANGLE (Intel(R) 82945G Express Chipset Family Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (SiS Mirage 3 Graphics Direct3D9Ex vs_2_0 ps_2_0)', 'ANGLE (NVIDIA GeForce GT 430)', 'ANGLE (AMD RADEON HD 6450 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon 3000 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) 4 Series Internal Chipset Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q35 Express Chipset Family (Microsoft Corporation - WDDM 1.0) Direct3D9Ex vs_0_0 ps_2_0)', 'ANGLE (NVIDIA GeForce GT 220 Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 7640G Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD 760G Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 6450 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 640 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 9200 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 610 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 6290 Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Mobility Radeon HD 4250 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 8600 GT Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 5570 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 6800 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) G45/G43 Express Chipset Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 4600 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA Quadro NVS 160M Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics 3000)', 'ANGLE (NVIDIA GeForce G100)', 'ANGLE (AMD Radeon HD 8610G + 8500M Dual Graphics Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Mobile Intel(R) 4 Series Express Chipset Family Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 7025 / NVIDIA nForce 630a (Microsoft Corporation - WDDM) Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) Q965/Q963 Express Chipset Family Direct3D9 vs_0_0 ps_2_0)', 'ANGLE (AMD RADEON HD 6350 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (ATI Radeon HD 5450 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce 9500 GT)', 'ANGLE (AMD Radeon HD 6500M/5600/5700 Series Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Mobile Intel(R) 965 Express Chipset Family)', 'ANGLE (NVIDIA GeForce 8400 GS Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (Intel(R) HD Graphics Direct3D9 vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GTX 560 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 620 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GTX 660 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon(TM) HD 6520G Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA GeForce GT 240 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (AMD Radeon HD 8240 Direct3D9Ex vs_3_0 ps_3_0)', 'ANGLE (NVIDIA Quadro NVS 140M)', 'ANGLE (Intel(R) Q35 Express Chipset Family Direct3D9 vs_0_0 ps_2_0)']; const WEBGL_VENDORS_ANDROID = ['Qualcomm', 'ARM']; const WEBGL_RENDERERS_ANDROID = ['Adreno (TM) 630', 'Mali-T830']; if (!this._WebGL) { this._WebGL = {}; const parser = require('ua-parser-js'); const machine = parser(userAgent); const rand = function (min, max) { return Math.floor(Math.random() * (max - min) + min); }; const randArr = function (arr) { return arr[Math.floor(Math.random() * arr.length)]; }; this._WebGL['s7936'] = 'WebKit'; this._WebGL['s7937'] = 'WebKit WebGL'; this._WebGL['s7938'] = 'WebGL 2.0 (OpenGL ES 3.0 Chromium)'; this._WebGL['s35724'] = 'WebGL GLSL ES 3.00 (OpenGL ES GLSL ES 3.0 Chromium)'; this._WebGL['s36347'] = 4096; this._WebGL['s36348'] = 30; this._WebGL['s33902'] = [1, 1]; this._WebGL['s33901'] = [1, 1024]; this._WebGL['s6408'] = rand(6400, 6420); this._WebGL['s35661'] = randArr([128, 192, 256]); this._WebGL['s36349'] = Math.pow(2, rand(9, 12)); this._WebGL['s34852'] = 8; this._WebGL['s3386'] = [32767, 32767]; this._WebGL['webgl2'] = true; if (machine.os.name.toLowerCase().includes('windows')) { this._WebGL['s7936'] = 'Mozilla'; this._WebGL['s7937'] = 'Mozilla'; this._WebGL['s37445'] = vendor; this._WebGL['s37446'] = WEBGL_RENDERERS_DESKTOP[Math.floor(Math.random() * WEBGL_RENDERERS_DESKTOP.length)]; } else if (machine.os.name.toLowerCase().includes('android')) { this._WebGL['s37445'] = WEBGL_VENDORS_ANDROID[Math.floor(Math.random() * WEBGL_VENDORS_ANDROID.length)]; this._WebGL['s37446'] = WEBGL_RENDERERS_ANDROID[Math.floor(Math.random() * WEBGL_RENDERERS_ANDROID.length)]; } else if (machine.os.name.toLowerCase().includes('linux')) { this._WebGL['s37445'] = vendor; this._WebGL['s37446'] = WEBGL_RENDERERS_DESKTOP[Math.floor(Math.random() * WEBGL_RENDERERS_DESKTOP.length)]; } else if (machine.os.name.toLowerCase().includes('apple') || machine.os.name.toLowerCase().includes('ios') || (machine.os.name.toLowerCase().includes('mac') && machine.browser.name.includes('Safari'))) { this._WebGL['s7938'] = 'WebGL 1.0'; this._WebGL['s35724'] = 'WebGL GLSL ES 1.0 (1.0)'; this._WebGL['s37445'] = 'Apple Inc.'; this._WebGL['s37446'] = 'Apple GPU'; this._WebGL['s36347'] = 512; this._WebGL['s36348'] = 15; this._WebGL['s34852'] = 1; this._WebGL['s33902'] = [1, 16]; this._WebGL['s33901'] = [1, 511]; this._WebGL['s3386'] = [16384, 16384]; this._WebGL['s36349'] = 224; this._WebGL['s35661'] = 32; this._WebGL['webgl2'] = false; } else if (machine.os.name.toLowerCase().includes('mac')) { this._WebGL['s37445'] = 'Intel Inc.'; this._WebGL['s37446'] = 'Intel HD Graphics 4000 OpenGL Engine'; } else { this._WebGL['s37445'] = vendor; this._WebGL['s37446'] = 'Google SwiftShader'; } this._WebGL['offset'] = Math.random(); } await page.evaluateOnNewDocument((session) => { (function (session) { function safeOverwrite(obj, prop, newVal) { let props = Object.getOwnPropertyDescriptor(obj, prop); props["value"] = newVal; return props; } let changeMap = {}; let paramChanges = { 3379: 16384, 3386: session['s3386'], 3410: 8, 3411: 8, 3412: 8, 3413: 8, 3414: 24, 3415: 8, 6408: session['s6408'], 34024: 16384, 30476: 16384, 34921: 16, 34930: 16, 35660: 16, 35661: session['s35661'], 36347: session['s36347'], 36349: session['s36349'], 7936: session['s7936'], 7937: session['s7937'], 37445: session['s37445'], 37446: session['s37446'], 7938: session['s7938'], 35724: session['s35724'], 36348: session['s36348'], 33902: session['s33902'], 33901: session['s33901'], 34852: session['s34852'] }; changeMap = Object.assign(changeMap, paramChanges); ["WebGLRenderingContext", "WebGL2RenderingContext"].forEach(function (ctx) { if (!window[ctx]) return; // Modify getParameter let oldParam = window[ctx].prototype.getParameter; Object.defineProperty(window[ctx].prototype, "getParameter", safeOverwrite(window[ctx].prototype, "getParameter", function (param) { if (changeMap[param]) return changeMap[param]; return oldParam.apply(this, arguments); }) ); // Modify bufferData (this updates the image hash) let oldBuffer = window[ctx].prototype.bufferData; Object.defineProperty(window[ctx].prototype, "bufferData", safeOverwrite(window[ctx].prototype, "bufferData", function () { for (let i = 0; i < arguments[1].length; i++) { arguments[1][i] += session['offset'] * 1e-3; } return oldBuffer.apply(this, arguments); }) ); }); if (!session['webgl2']) { paramChanges = {}; Object.getOwnPropertyNames(WebGL2RenderingContext).forEach(property => { if (Number.isInteger(WebGL2RenderingContext[property]) && WebGL2RenderingContext[property] > 0) { paramChanges[property] = undefined; } }); let oldParam = WebGL2RenderingContext.prototype.getParameter; Object.defineProperty(WebGL2RenderingContext.prototype, "getParameter", safeOverwrite(WebGL2RenderingContext.prototype, "getParameter", function (param) { if (paramChanges[param]) return paramChanges[param]; return oldParam.apply(this, arguments); }) ); WebGL2RenderingContext = undefined; HTMLCanvasElement.prototype.getContext = function (orig) { return function (type) { return !type.includes("webgl2") ? orig.apply(this, arguments) : null } }(HTMLCanvasElement.prototype.getContext) HTMLCanvasElement.prototype.getContext.toString = () => 'function getContext() { [native code] }'; } })(session) }, this._WebGL); }

/* ./api/helper/cleanPrice.js */
//Extract clean price without decimal function cleanPrice(rawPrice) { if (rawPrice.includes(',') || rawPrice.includes('.')) { rawPrice = rawPrice.match(/[,.\d]+(?=[.,]\d+)/g)[0]; return rawPrice.replace(/[.,]/g, ''); } else { rawPrice = rawPrice.match(/\d+/g); return rawPrice[0]; } } module.exports = { cleanPrice };

/* ./api/helper/click.js */
const { delay } = require('./packages'); async function elementClick(page, selector, valueToClick, delayTime = 0) { // if delay is set, wait for that amount of time if (delayTime) { delay(delayTime); } selector = selector.replace('{{valueToClick}}', valueToClick.trim()); if (selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//')) { await page.waitForXPath(selector); const elements = await page.$x(selector); await elements[0].click(); } else { await page.waitForSelector(selector); await page.evaluate((selector) => { document.querySelector(selector).click(); }, selector); //await page.click(selector) } // wait for the page to load await page.waitForResponse((response) => response.status() === 200); } module.exports = { elementClick };

/* ./api/helper/delay.js */
/** For delay time **/ function delay(time) { return new Promise(function (resolve) { setTimeout(resolve, time); }); } module.exports = { delay };

/* ./api/helper/getVariants.js */
const { elementSelector } = require('./selector'); const { cleanPrice } = require('./cleanPrice'); const { elementClick } = require('./packages'); // Resolve images url async function fixImage(imageUrls) { imageUrls.forEach((imageUrl, index) => { if (imageUrl[index]) { if (!imageUrl[index].startsWith('https://')) { if (imageUrl[index].startsWith('//')) { imageUrl[index] = 'https:' + imageUrl[index]; } else { imageUrl[index] = 'https://' + imageUrl[index]; } } } }); } // Get Clean price async function GetCleanPrice(page, data) { const price = cleanPrice( (await elementSelector( page, data.price.selector, data.price.attribute || null, data.price.regex || null, data.price.groups || [], false )) || '' ); // if price not a number and empty if (isNaN(price)) throw ( (new Error('Price is not a number >' + price), console.log('\x1b[31m%s\x1b[0m', 'Price is not a number >' + price)) ); if (price === '') throw (new Error('Price is empty'), console.log('\x1b[31m%s\x1b[0m', 'Price is empty')); return price; } // Get option 1 async function GetOption1( page, data, option3Values, option3Id, indexOption3Id, option2Values, option2Id, indexOption2Id, arrayOptions = [] ) { // Default values const price = ''; const sku = ''; const option1Values = []; const OutOfStockSTDIndicator = ''; const variantHandle = ''; if (data.OutOfStockSTDIndicator.selector) { OutOfStockSTDIndicator = (await elementSelector( page, data.OutOfStockSTDIndicator.selector, data.OutOfStockSTDIndicator.attribute || null, data.OutOfStockSTDIndicator.regex || null, data.OutOfStockSTDIndicator.groups || [], false )) || ''; } if (OutOfStockSTDIndicator.length === 0) { // Option 1 values option1Values = (await elementSelector( page, data.option1.selector, data.option1.attribute || null, data.option1.regex || null, data.option1.groups || [], true )) || ['STD']; } // Image srcs const imageSrcs = await elementSelector( page, data.imageSrc.selector, data.imageSrc.attribute || null, data.imageSrc.regex || null, data.imageSrc.groups || [], true ); // if imageSrcs is empty if (!imageSrcs) throw ( (new Error('Images are empty, please check your selector'), console.log('\x1b[31m%s\x1b[0m', 'Images are empty, please check your selector')) ); if (!data.clickOption1.selector) { sku = await elementSelector( page, data.sku.selector, data.sku.attribute || null, data.sku.regex || null, data.sku.groups || [], false ); // Get price price = GetCleanPrice(page, data); // Get url after click variantHandle = page.url(); } /************************************************** * Iterate over option 1 values * **************************************************/ for (let index = 0; index < option1Values.length || index < imageSrcs.length; index++) { // Default values const price = ''; const sku = ''; const quantity = ''; const options = []; // Check if clickOption1 is set if (data.clickOption1.selector) { // Click on option 1 await elementClick(page, data.clickOption1.selector, option1Values[index], 0); // Get url after click variantHandle = page.url(); // Get price price = await GetCleanPrice(page, data); sku = await elementSelector( page, data.sku.selector, data.sku.attribute || null, data.sku.regex || null, data.sku.groups || [], false ); } // options array to return if (option3Id && option2Id) { options = [ { option1: data.option1Name, value: option1Values[index] || '', }, { option2: data.option2Name, value: option2Values[indexOption2Id], }, { option3: data.option3Name, value: option3Values[indexOption3Id], }, ]; } if (option2Id) { options = [ { option1: data.option1Name, value: option1Values[index] || '', }, { option2: data.option2Name, value: option2Values[indexOption2Id], }, ]; } else { options = [ { option1: data.option1Name, value: option1Values[index] || '', }, ]; } if (data.quantity.selector && option1Values[index]) { quantity = await elementSelector( page, data.quantity.selector, data.quantity.attribute || null, data.quantity.regex || null, data.quantity.groups || [], false ); } else { quantity = 5; } const imageSrc = (await fixImage(imageSrcs[index])) || ''; const option = { variantId: index + 1 || '', variantHandle: variantHandle || '', price: price || '', sku: sku || '', options: options || [], quantity: quantity || null, imageSrc: imageSrc || '', }; return option ? arrayOptions.push(option) : arrayOptions; } } // Get option 2 and option 1 async function GetOption2AndOption1(page, data, option3Values, option3Id, indexOption3Id, arrayOptions = []) { const option2Values = ( await elementSelector( page, data.color.selector || null, data.color.attribute || null, data.color.regex || null, data.color.groups || [], false ) ).trim() || ''; const option2IDs = ( await elementSelector( page, data.color.selector || null, data.color.attribute || null, data.color.regex || null, data.color.groups || [], false ) ).trim() || ''; /************************************************** * Iterate over option 2 IDs * **************************************************/ option2IDs.forEach(async (option2Id, indexOption2Id) => { return await GetOption1( page, data, option3Values, option3Id, indexOption3Id, option2Values, option2Id, indexOption2Id, arrayOptions ); }); return []; } // Get option 3 and option 2 and option 1 async function GetOption3AndOption2AndOption1(page, data) { // Get option 3 values const option3Values = (await elementSelector( page, data.option3, data.option3.attribute || null, data.option3.regex || null, data.option3.groups || [], true )) || ''; // Get option 3 IDs const option3IDs = await elementSelector( page, data.option3Id.selector, data.option3Id.attribute || null, data.option3Id.regex || null, data.option3Id.groups || [], true ); /************************************************** * Iterate over option 3 IDs * **************************************************/ option3IDs.forEach(async (option3Id, indexOption3Id) => { return await GetOption2AndOption1( page, data, option3Values, option3Id, indexOption3Id, option2Values, (arrayOptions = []) ); }); return []; } module.exports = { GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, };

/* ./api/helper/packages.js */
'use strict'; /* * Purpose : To load all Node.Js Packages * Package : NPM Packages * Developed By : Tishko Rasoul (tishko.rasoulgmail.com) */ const puppeteer = require('puppeteer-extra'), stealth = require('puppeteer-extra-plugin-stealth'), scrollToBottom = require('scroll-to-bottomjs'), { check, validationResult } = require('express-validator'), fs = require('fs'), Xvfb = require('xvfb'), useProxy = require('puppeteer-page-proxy'), { elementSelector } = require('./selector'), { elementClick } = require('./click'), { validate } = require('./validate'), { delay } = require('./delay'), { isValidStore } = require('./validate'), { blockResources } = require('./blockResources'), { cleanPrice } = require('./cleanPrice'), { GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1 } = require('./getVariants'), { elementClick } = require('./click'); module.exports = { delay, puppeteer, scrollToBottom, check, validationResult, fs, validate, Xvfb, stealth, useProxy, elementSelector, elementClick, isValidStore, blockResources, cleanPrice, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, elementClick, };

/* ./api/helper/selector.js */
async function mainSelector(page, selector, attribute) { if (selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//')) { if (attribute) { return await page.evaluate( async ({ selector, attribute }) => { return Array.from( (function () { var arr = []; var results = document.evaluate( selector, document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null ); while ((node = results.iterateNext())) { arr.push(node); } return arr; })() ).map((el) => el .getAttribute(attribute) .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&39;/g, "'") .replace(/&amp;/g, '&') .replace(/\n/g, '') .trim() ); }, { selector, attribute } ); } else { return await page.evaluate(async (selector) => { return Array.from( (function () { var arr = []; var results = document.evaluate( selector, document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null ); while ((node = results.iterateNext())) { arr.push(node); } return arr; })() ).map((el) => el.textContent .replace(/(\r\n|\n|\r)/gm, '') .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&39;/g, "'") .replace(/&amp;/g, '&') .replace(/\n/g, '') .trim() ); }, selector); } } else { if (attribute) { return await page.evaluate( ({ selector, attribute }) => { return Array.from(document.querySelectorAll(selector)).map((el) => el .getAttribute(attribute) .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&39;/g, "'") .replace(/&amp;/g, '&') .replace(/\n/g, '') .trim() ); }, { selector, attribute } ); } else { return await page.evaluate((selector) => { return Array.from(document.querySelectorAll(selector)).map((el) => el.textContent .replace(/(\r\n|\n|\r)/gm, '') .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&39;/g, "'") .replace(/&amp;/g, '&') .replace(/\n/g, '') .trim() ); }, selector); } } } async function elementSelector(page, selector, attribute, regex, groups, queryAll) { if (!queryAll) { if (regex) { if (groups.length > 0) { // if we have groups var arr = []; const tmpSelector = await mainSelector(page, selector, attribute); for (let index = 0; index < groups.length; index++) { arr.push(tmpSelector[0].match(regex)[groups[index]]); } return arr.join(''); } else { //if we have only regex const tmpSelector = await mainSelector(page, selector, attribute); var regx = tmpSelector[0].match(regex); return regx.join(''); } } else { const tmpSelector = await mainSelector(page, selector, attribute); return tmpSelector[0]; //return the first array } } else { if (regex) { // if we have groups if (groups.length > 0) return Array.from(await mainSelector(page, selector, attribute)).map((item) => Array.from(groups) .map((group) => item.match(new RegExp(regex, 'gi'))[group]) .join('') ); //if we have only regex else return Array.from(await mainSelector(page, selector, attribute)).map((item) => item.match(new RegExp(regex, 'gi')).join('') ); } else { return await mainSelector(page, selector, attribute); } } } module.exports = { elementSelector };

/* ./api/helper/validate.js */
const { check } = require("express-validator"), fs = require("fs"); function validate(method) { switch (method) { case "search": { return [ check("handle") .notEmpty() .withMessage("handle field is required") .trim(), ]; } break; } } async function isValidStore(store) { if ( Array.from(fs.readdirSync("./api/models/data")) .map((e) => e.replace(".json", "")) .includes(store) ) return true; else return false; } module.exports = { validate, isValidStore };

/* ./api/routes/storeRoute.js */
"use strict"; /* * Purpose : For All Website API's Routing * Package : Router * Developed By : Tishko Rasoul (tishko.rasoul@gmail.com) */ const express = require("express"), router = express.Router(), storeController = require("../controllers/storesController"), { validate } = require("../helper/validate"); /*Website Routings */ router.post("/search", validate("search"), storeController.search); module.exports = router;

/* ./index.js */
"use strict"; /* Purpose: Running node.js and initialize. * Author : Tishko Rasoul (tishko.rasoul@gmail.com) */ const app = require('express')(), cors = require('cors'), http = require('http'), compression = require('compression'), bodyParser = require('body-parser'); /* Require Enviornment File */ require('dotenv').config(); /* Require Preety Error / show errors beautifully */ require('pretty-error').start(); /* Create Server */ var server = http.createServer(app); /* To set port */ app.set('port', process.env.PORT || 3000); /* Compress all HTTP responses */ app.use(compression()); /* To Listen Port */ server.listen(app.get('port'), function () { console.log(`Express server listening on port ${app.get('port')}`); }); /* Cross Origin */ app.use(cors()) /* BodyParser Middleware */ app.use(bodyParser.json()); app.use(bodyParser.urlencoded({limit: '100mb', extended: true})); /* Handle Invalid JSON */ app.use(function(err, req, res, next){ if(err.status === 400){ var ErrorObj = {ResponseCode: 400, Message:'Invalid JSON request.'} return res.status(400).json(ErrorObj); } return next(err); // if it's not a 400, let the default error handling do it. }) app.use(function (req, res, next){ res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept"); next(); }) /* API Routings */ app.use('/api', require('./api/routes/storeRoute')); /* Redirect On Website */ app.get('/', function(req, res) { return res.send('Welcome To Web scraping APP'); }) /* Handle Invalid URL */ app.all('*', (req, res, next) => { res.status(404).json({ResponseCode: 404, Message: `Can't find ${req.originalUrl} on this server!`}); }); module.exports = { app }; /* End of file index.js */ /* Location: ./index.js */

