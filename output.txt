-- .dockerignore
-- .env
-- .vscode
|   | -- launch.json
|   | -- tasks.json
-- docker-compose.yml
-- Dockerfile
-- index.js
-- localStorage.json
-- notes.txt
-- package.json
-- src
|   | -- controllers
|  |   | -- scrapeCollection.js
|  |   | -- scrapeProduct.js
|   | -- helper
|  |   | -- blockResources.js
|  |   | -- cleanPrice.js
|  |   | -- click.js
|  |   | -- delay.js
|  |   | -- descriptionBuilder.js
|  |   | -- getVariants.js
|  |   | -- htmlSelector.js
|  |   | -- packages.js
|  |   | -- processUrl.js
|  |   | -- selector.js
|  |   | -- validate.js
|   | -- models
|  |   | -- data
|  |      | -- browserleaks.json
|  |      | -- defacto.json
|  |      | -- github.json
|  |      | -- hm.json
|  |      | -- koton.json
|  |      | -- lcwaikiki.json
|  |      | -- mango.json
|  |      | -- sannysoft.json
|  |      | -- trackip.json
|  |      | -- trendyol.json
|  |      | -- zara.json
|   | -- routes
|      | -- api
|     |   | -- v1
|     |      | -- index.js
|      | -- auth
-- store.json
-- temp.json
/* ./index.js */
'use strict'; /* Purpose: Running node.js and initialize. * Author : Tishko Rasoul (tishko.rasoul@gmail.com) */ const { app, cors, http, compression, bodyParser, uuidv4 } = require('./src/helper/packages'); /* Require Enviornment File */ require('dotenv').config(); /* Require Preety Error / show errors beautifully */ require('pretty-error').start(); /* Create Server */ var server = http.createServer(app); /* To set port */ app.set('port', process.env.PORT || 3000); /* Compress all HTTP responses */ app.use(compression()); /* To Listen Port */ server.listen(app.get('port'), function () { console.log(`Express server listening on port ${app.get('port')}`); }); /* Cross Origin */ app.use(cors()); /* BodyParser Middleware */ app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ limit: '100mb', extended: true })); /* Handle Invalid JSON */ app.use(function (err, req, res, next) { if (err.status === 400) { var ErrorObj = { ResponseCode: 400, Message: 'Invalid JSON request.' }; return res.status(400).json(ErrorObj); } return next(err); // if it's not a 400, let the default error handling do it. }); app.use(function (req, res, next) { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept'); next(); }); /* Add UUID to each log request */ app.use((req, res, next) => { req.id = uuidv4().split('-')[0]; const originalConsole = { log: console.log, error: console.error, warn: console.warn, info: console.info, }; const overrideConsole = (method) => (...args) => { // Prepend the UUID to the first argument args[0] = `[${req.id}] ` + args[0]; originalConsole[method].apply(console, args); }; console.log = overrideConsole('log'); console.error = overrideConsole('error'); console.warn = overrideConsole('warn'); console.info = overrideConsole('info'); res.on('finish', () => { console.log = originalConsole.log; console.error = originalConsole.error; console.warn = originalConsole.warn; console.info = originalConsole.info; }); next(); }); /* API Routings */ app.use('/api/v1', require('./src/routes/api/v1')); /* Redirect On Website */ app.get('/', function (req, res) { return res.send('Welcome To Web scraping APP'); }); /* Handle Invalid URL */ app.all('*', (req, res, next) => { res.status(404).json({ message: `Can't find ${req.originalUrl} on this server!` }); }); module.exports = { app }; /* End of file index.js */ /* Location: ./index.js */

/* ./src/controllers/scrapeCollection.js */
'use strict'; /* * Purpose : Website Search API * Package : Controller * Developed By : Tishko Rasoul (tishko.rasoul@gmail.com) */ const { puppeteer, scrollToBottom, fs, Xvfb, stealth, useProxy, elementSelector, delay, blockResources, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, processDescriptions, getStoreName, } = require('../helper/packages.js'); async function scrapeProduct(req, res) { // get handle from request body const handle = req.body.handle; // Get store name const store = await getStoreName(handle); const data = await require('../models/data/' + store); const userAgents = [ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:70.0) Gecko/20100101 Firefox/70.0', ]; //const userAgent = userAgents[Math.floor(Math.random() * userAgents.length)] const userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'; //const userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" const xvfb = new Xvfb({ silent: true, xvfb_args: ['-screen', '0', '1366x768x24', '-ac'], }); var args = []; args.push(`--no-sandbox`); args.push(`--disable-setuid-sandbox`); args.push(`--window-size=1366x768`); args.push(`--blink-settings=imagesEnabled=true`); args.push(`--disable-translate`); args.push(`--window-position=0,0`); args.push('--hide-scrollbars'); args.push('--mute-audio'); args.push(`--disable-speech-api`); args.push(`--user-agent=${userAgent}`); args.push(`--disable-web-security`); if (!data.isHeadless) { await xvfb.startSync(); args.push('--use-fake-device-for-media-stream'); args.push('--display=' + xvfb._display); } var browser; /* Initialize Browser */ try { // Enable stealth plugin if (!data.isHeadless) { puppeteer.use( stealth({ enabledEvasions: new Set([ /* evasions for headless only 'chrome.app', 'chrome.csi', 'chrome.loadTimes', 'chrome.runtime', 'navigator.permissions', 'navigator.plugins', 'window.outerdimensions' */ //launch args (the webdriver fix is very much needed depending on how you launch chrome, just the method changed in v89) and sourceurl 'defaultArgs', // appears to be necessary to prevent iframe issues? https://github.com/puppeteer/puppeteer/issues/1106 'iframe.contentWindow', // necessary if running chromium instad of chrome 'media.codecs', // Doesn't appear to be necessary with chrome version > 89? 'navigator.webdriver', // Strips puppeteer/CDP artifacts from stacktrace 'sourceurl', /* thou shall not lie about thou hardware stack 'user-agent-override', // better off using this plugin manually than the default MSFT UA imo 'webgl.vendor', // Try and use common hardware instead */ ]), }) ); } else { stealth().enabledEvasions.delete('user-agent-override'); stealth().enabledEvasions.delete('webgl.vendor'); puppeteer.use(stealth()); } /* Launch Browser */ browser = await puppeteer.launch({ headless: data.isHeadless ? 'new' : false, executablePath: '/usr/bin/chromium-browser', args: args, slowMo: 0, }); // First page const page = (await browser.pages())[0]; // User agent override await require('puppeteer-extra-plugin-stealth/evasions/user-agent-override')({ userAgent: userAgent, locale: 'en-US,en', maskLinux: true, }).onPageCreated(page); //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.hardwareConcurrency`)(8).onPageCreated(page) //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.vendor`)({ vendor: 'Google Inc.' }).onPageCreated(page) // WebGL Vendor override await require(`puppeteer-extra-plugin-stealth/evasions/webgl.vendor`)({ vendor: 'Google Inc. (Intel)', renderer: 'Intel, Intel(R) HD Graphics 4000 Direct3D11 vs_5_0 ps_5_0, D3D11', }).onPageCreated(page); // Randomize proxy var proxies = data.proxies[Math.floor(Math.random() * data.proxies.length)]; if (data.debug && proxies) { console.log(proxies); // Use Proxy await useProxy(page, proxies); } //Randomize viewport size await page.setViewport({ width: 1366 + Math.floor(Math.random() * 100), height: 768 + Math.floor(Math.random() * 100), deviceScaleFactor: 1, hasTouch: false, isLandscape: false, isMobile: false, }); await page.setJavaScriptEnabled(true); await page.setDefaultNavigationTimeout(0); //await page.setUserAgent(userAgent); // Saved cookies reading const cookies = fs.readFileSync('cookies.json', 'utf8'); const deserializedCookies = JSON.parse(cookies); await page.setCookie(...deserializedCookies); //await page.emulateTimezone('Asia/Baghdad'); await page.setRequestInterception(true); //Block unnecessary resource types and urls await blockResources(page, data); // Go to page await page.goto(req.body.handle, { waitUntil: data.waitUntil, timeout: 0, }); // Randomly mouse movement to bypass detections await page.mouse.move(100, Math.floor(Math.random() * 100)); await page.mouse.move(200, Math.floor(Math.random() * 100)); // Save cookies const saveCookies = await page.cookies(); await fs.promises.writeFile('./cookies.json', JSON.stringify(saveCookies, null, 2)); // Scroll to bottom if (data.scrollToBottom) await page.evaluate(scrollToBottom, { frequency: 200, timing: 0 }); if (data.debug) await delay(8000); // debug if (data.debug) { // fs.writeFileSync('debug/docs/' + store + '.html', await page.evaluate(() => { // return document.querySelectorAll("html")[0].outerHTML // }), { // encoding: 'utf8', // flag: 'w' // }) // console.log(await page.evaluate(() => { // var arr = [] // arr.push(navigator.webdriver) // arr.push(navigator.language) // arr.push(navigator.deviceMemory) // arr.push(navigator.hardwareConcurrency) // arr.push(navigator.platform) // arr.push(window.screen.width) // arr.push(window.screen.height) // return arr // })) await page.screenshot({ path: 'debug/screenshoots/' + store + '.png', fullPage: true, }); } // Wait for Selector if (data.productConfig.container) { // Correct the method to 'startsWith' if ( data.productConfig.container.startsWith('//') || data.productConfig.container.startsWith('(//') || data.productConfig.container.startsWith('((//') ) { await page.waitForXPath(data.productConfig.container, { timeout: 30000, }); } else { await page.waitForSelector(data.productConfig.container, { timeout: 30000, }); } } else { throw new Error('Container is empty, please check your selector'); } const response = {}; response.handle = req.body.handle; const title = await elementSelector( page, data.productConfig.title.selectors, data.productConfig.title.attribute, data.productConfig.title.regex, data.productConfig.title.groups, true, data.productConfig.title.valueToReplace ); if (Array.isArray(title)) { response.title = title.join(' '); } else { response.title = title || ''; } response.description = await processDescriptions(page, data); const vendor = data.productConfig.vendor.name || (await elementSelector( page, data.productConfig.vendor, data.productConfig.vendor.attribute, data.productConfig.vendor.regex, data.productConfig.vendor.groups, true, data.productConfig.vendor.valueToReplace )); if (Array.isArray(vendor)) { response.vendor = vendor.join(' '); } else { response.vendor = vendor || ''; } const category = await elementSelector( page, data.productConfig.category.selectors, data.productConfig.category.attribute, data.productConfig.category.regex, data.productConfig.category.groups, true, data.productConfig.category.valueToReplace ); if (Array.isArray(category)) { response.category = category.join(' '); } else { response.category = category.trim() || ''; } // if (data.productConfig.option3.selectors.length) { // response.variants = await GetOption3AndOption2AndOption1(page, data); // } else if (data.productConfig.option2.selectors.length) { // response.variants = await GetOption2AndOption1(page, data, null, null, null, []); // } else { // } const option3AndOption2AndOption1 = await GetOption3AndOption2AndOption1(page, data); const option2AndOption1 = await GetOption2AndOption1(page, data, null, null, null, []); const option1 = await GetOption1(page, data, null, null, null, null, null, null, []); response.variants = option3AndOption2AndOption1.length ? option3AndOption2AndOption1 : option2AndOption1.length ? option2AndOption1 : option1.length ? option1 : []; response.message = 'success'; console.log('\x1b[32m%s\x1b[0m', 'Succeed response'); //green return res.status(200).json(response); } catch (e) { console.log('\x1b[31m%s\x1b[0m', e.message); if (e.message.includes('Waiting failed')) { return res.status(500).json({ message: e.message, }); } else if (e.message.includes('Timeout exceeded while waiting for event')) { return res.status(500).json({ message: e.message, }); } else { console.log('err', e); return res.status(500).json({ message: 'Some error occured Or data not found, please try again.', }); } } finally { if (!data.isHeadless) { xvfb.stopSync(); } browser.close(); } } module.exports = { scrapeProduct };

/* ./src/controllers/scrapeProduct.js */
'use strict'; /* * Purpose: Website Search API * Package: Controller * Developed By: Tishko Rasoul (tishko.rasoul@gmail.com) */ const { puppeteer, scrollToBottom, fs, Xvfb, stealth, useProxy, elementSelector, delay, blockResources, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, processDescriptions, getStoreName, } = require('../helper/packages.js'); function applyStealthPlugin(data, puppeteer, stealth) { if (data.isHeadless) { puppeteer.use( stealth({ enabledEvasions: new Set([ /* evasions for headless only 'chrome.app', 'chrome.csi', 'chrome.loadTimes', 'chrome.runtime', 'navigator.permissions', 'navigator.plugins', 'window.outerdimensions' */ //launch args (the webdriver fix is very much needed depending on how you launch chrome, just the method changed in v89) and sourceurl 'defaultArgs', // appears to be necessary to prevent iframe issues? https://github.com/puppeteer/puppeteer/issues/1106 'iframe.contentWindow', // necessary if running chromium instad of chrome 'media.codecs', // Doesn't appear to be necessary with chrome version > 89? 'navigator.webdriver', // Strips puppeteer/CDP artifacts from stacktrace 'sourceurl', /* thou shall not lie about thou hardware stack 'user-agent-override', // better off using this plugin manually than the default MSFT UA imo 'webgl.vendor', // Try and use common hardware instead */ ]), }) ); } else { puppeteer.use( stealth({ enabledEvasions: new Set([ 'defaultArgs', 'iframe.contentWindow', 'media.codecs', 'navigator.webdriver', 'sourceurl', ]), }) ); } } async function configurePage(page, userAgent, data) { // User agent override await require('puppeteer-extra-plugin-stealth/evasions/user-agent-override')({ userAgent: userAgent, locale: 'en-US,en', maskLinux: true, }).onPageCreated(page); //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.hardwareConcurrency`)(8).onPageCreated(page) //await require(`puppeteer-extra-plugin-stealth/evasions/navigator.vendor`)({ vendor: 'Google Inc.' }).onPageCreated(page) await page.setViewport({ width: 1366 + Math.floor(Math.random() * 100), height: 768 + Math.floor(Math.random() * 100), deviceScaleFactor: 1, hasTouch: false, isLandscape: false, isMobile: false, }); const cookies = fs.readFileSync('cookies.json', 'utf8'); const deserializedCookies = JSON.parse(cookies); await page.setCookie(...deserializedCookies); await page.setRequestInterception(true); await blockResources(page, data); if (data.scrollToBottom) { await page.evaluate(scrollToBottom, { frequency: 200, timing: 0 }); } } async function navigateAndProcessPage(page, data, url, store) { await page.goto(url, { waitUntil: data.waitUntil, timeout: 0, }); await page.mouse.move(100, Math.floor(Math.random() * 100)); await page.mouse.move(200, Math.floor(Math.random() * 100)); if (data.debug) { await delay(8000); await page.screenshot({ path: `../../debug/screenshoots/${store}.png`, fullPage: true }); } } function handleScrapeError(res, error) { let message = error.message; let statusCode = 500; if (message.includes('Waiting failed')) { // Specific error handling for waiting failure } else if (message.includes('Timeout exceeded while waiting for event')) { // Specific error handling for timeout } else { // Generic error handling console.error('Error:', error); message = 'Some error occurred or data not found, please try again.'; } return res.status(statusCode).json({ message }); } async function extractDataFromPage(page, data, handle) { const response = { handle }; // Extract title const title = await elementSelector( page, data.productConfig.title.selectors, data.productConfig.title.attribute, data.productConfig.title.regex, data.productConfig.title.groups, true, data.productConfig.title.valueToReplace ); response.title = Array.isArray(title) ? title.join(' ') : title || ''; // Extract description response.description = await processDescriptions(page, data); // Extract vendor const vendor = await elementSelector( page, data.productConfig.vendor.selectors, data.productConfig.vendor.attribute, data.productConfig.vendor.regex, data.productConfig.vendor.groups, true, data.productConfig.vendor.valueToReplace ); response.vendor = Array.isArray(vendor) ? vendor.join(' ') : vendor || ''; // Extract category const category = await elementSelector( page, data.productConfig.category.selectors, data.productConfig.category.attribute, data.productConfig.category.regex, data.productConfig.category.groups, true, data.productConfig.category.valueToReplace ); response.category = Array.isArray(category) ? category.join(' ') : category.trim() || ''; // Extract variants const variants = await determineVariants(page, data); response.variants = variants; return response; } async function determineVariants(page, data) { let variants = []; // Check if Option3 variants exist and extract them if (data.productConfig.option3 && data.productConfig.option3.selectors.length) { variants = await GetOption3AndOption2AndOption1(page, data); } // Check if Option2 variants exist and extract them else if (data.productConfig.option2 && data.productConfig.option2.selectors.length) { variants = await GetOption2AndOption1(page, data); } // Check if Option1 variants exist and extract them else if (data.productConfig.option1 && data.productConfig.option1.selectors.length) { variants = await GetOption1(page, data); } return variants; } async function getUserAgent() { const userAgents = [ 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:70.0) Gecko/20100101 Firefox/70.0', ]; //const userAgent = userAgents[Math.floor(Math.random() * userAgents.length)] const userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'; //const userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" return userAgent; } async function scrapeProduct(req, res) { const handle = req.body.handle; const store = await getStoreName(handle); const data = await require(`../models/data/${store}`); const userAgent = await getUserAgent(); const xvfb = new Xvfb({ silent: true, xvfb_args: ['-screen', '0', '1366x768x24', '-ac'], }); let args = [ '--no-sandbox', '--disable-setuid-sandbox', '--window-size=1366x768', '--blink-settings=imagesEnabled=true', '--disable-translate', '--window-position=0,0', '--hide-scrollbars', '--mute-audio', '--disable-speech-api', `--user-agent=${userAgent}`, '--disable-web-security', ]; if (!data.isHeadless) { await xvfb.startSync(); args.push('--use-fake-device-for-media-stream'); args.push(`--display=${xvfb._display}`); } let browser; try { applyStealthPlugin(data, puppeteer, stealth); browser = await puppeteer.launch({ headless: data.isHeadless ? 'new' : false, executablePath: '/usr/bin/chromium-browser', args: args, slowMo: 0, }); const page = (await browser.pages())[0]; await configurePage(page, userAgent, data); await navigateAndProcessPage(page, data, handle, store); const response = await extractDataFromPage(page, data, handle); console.log('\x1b[32m%s\x1b[0m', 'Succeed response'); // Green return res.status(200).json(response); } catch (e) { console.error('\x1b[31m%s\x1b[0m', e.message); return handleScrapeError(res, e); } finally { if (!data.isHeadless) await xvfb.stopSync(); if (browser) await browser.close(); } } module.exports = { scrapeProduct };

/* ./src/helper/blockResources.js */
async function blockResources(page, data) { page.on("request", async (request) => { var resourceType; var url = true; // Block resource types for (let index = 0; index < data.blockResourceTypes.length; index++) { if (request.resourceType() === data.blockResourceTypes[index]) resourceType = true; } // Whitelist urls if (!resourceType) { for (let index = 0; index < data.whiteListUrls.length; index++) { if (request.url().includes(data.whiteListUrls[index])) url = null; } } // Block urls if (!url) { for (let index = 0; index < data.blockUrls.length; index++) { if (request.url().includes(data.blockUrls[index])) url = true; } } // Print blocked urls if (resourceType || url) { if (url) { //console.log(request.resourceType()); if (data.debug) console.log("\x1b[31m%s\x1b[0m", request.url()); } request.abort(); // Abort blocked urls } else { //console.log(request.resourceType()); if (data.debug) // Print unblocked urls console.log("\x1b[32m%s\x1b[0m", '"' + request.url() + '",'); request.continue(); // Continue unblocked urls } }); } module.exports = { blockResources };

/* ./src/helper/cleanPrice.js */
//Extract clean price without decimal function cleanPrice(rawPrice) { if (rawPrice) { if (rawPrice.includes(',') || rawPrice.includes('.')) { rawPrice = rawPrice.match(/[,.\d]+(?=[.,]\d+)/g)[0]; return rawPrice.replace(/[.,]/g, ''); } else { rawPrice = rawPrice.match(/\d+/g); return rawPrice[0]; } } else { return ''; } } module.exports = { cleanPrice };

/* ./src/helper/click.js */
'use strict'; const { delay } = require('./delay'); async function elementClick(page, selector, valueToReplace, delayTime = 0) { // Replace the placeholder in selector if needed selector = valueToReplace ? selector.replace('{{valueToReplace}}', valueToReplace.trim()) : selector; // Determine whether the selector is an XPath const isXPath = selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//'); // Wait for the element based on its selector type const waitFor = isXPath ? page.waitForXPath(selector) : page.waitForSelector(selector); await waitFor; // Check if the element exists const elementToClick = isXPath ? (await page.$x(selector))[0] : await page.$(selector); if (elementToClick) { // yellow color console console.log('\x1b[33m%s\x1b[0m', 'Element found, clicking:', selector); await elementToClick.evaluate((b) => b.click()); await page.waitForNetworkIdle(); await delay(delayTime); } else { console.log('Element not found to click:', selector); } } // await page.waitForTimeout(1000); // Wait for the page to load, this is not a robust way to check for page load // It's better to wait for a specific response or navigation after a click //await page.waitForResponse((response) => response.status() === 200); module.exports = { elementClick };

/* ./src/helper/delay.js */
/** For delay time **/ function delay(time) { return new Promise(function (resolve) { setTimeout(resolve, time); }); } module.exports = { delay };

/* ./src/helper/descriptionBuilder.js */
const { htmlSelector } = require('./htmlSelector'); const { elementSelector } = require('./selector'); // Function to handle the concatenation of descriptions function concatenateDescriptions(descriptions, isHTML = false) { const separator = isHTML ? '</br></br>' : ''; return descriptions.join('</br>') + separator; } // Function to create an HTML list from an array function createList(items) { const listItems = items.map((item) => `<li>${item}</li>`).join(''); return `<ul>${listItems}</ul></br>`; } // Function to create an HTML table from an array // Function to create an HTML table from an array with specific row logic function createTable(items, numberOfCol = 5, hasTableHeader = false) { numberOfCol = numberOfCol || 5; // Ensure numberOfCol is set const createRow = (rowData, isHeader = false) => { const tag = isHeader ? 'th' : 'td'; return `<tr>${rowData.map((item) => `<${tag}>${item}</${tag}>`).join('')}</tr>`; }; let currentRowData = []; let tableRows = items.reduce((acc, item, index) => { currentRowData.push(item); const isRowEnd = index % numberOfCol === numberOfCol - 1 || index === items.length - 1; if (isRowEnd) { // If hasTableHeader is true and this is the first row, create a header row const isHeaderRow = hasTableHeader && acc.length === 0; acc.push(createRow(currentRowData, isHeaderRow)); currentRowData = []; // Reset for the next row } return acc; }, []); return `<table><tbody>${tableRows.join('')}</tbody></table>`; } async function processDescriptions(page, data) { let tempDescription = ''; // Process normal descriptions let descriptions = []; if (data.productConfig.descriptions.selectors.length) { if (data.productConfig.descriptions.isHTML) { descriptions = await htmlSelector( page, data.productConfig.descriptions.selectors, true, data.productConfig.descriptions.valueToReplace ); } else { descriptions = await elementSelector( page, data.productConfig.descriptions.selectors, data.productConfig.descriptions.attribute, data.productConfig.descriptions.regex, data.productConfig.descriptions.groups, true, data.productConfig.descriptions.valueToReplace ); } } // Process HTML descriptions let tableDescriptions = []; if (data.productConfig.descriptions.selectors.length) { tableDescriptions = await elementSelector( page, data.productConfig.tableDescriptions.selectors, data.productConfig.tableDescriptions.attribute, data.productConfig.tableDescriptions.regex, data.productConfig.tableDescriptions.groups, true, data.productConfig.tableDescriptions.valueToReplace ); } // Combine descriptions if (descriptions.length) { tempDescription += descriptions.length > 2 ? createList(descriptions) : concatenateDescriptions(descriptions, tableDescriptions.length > 0); } // Append HTML descriptions in a table if (tableDescriptions.length) { tempDescription += createTable( tableDescriptions, data.productConfig.tableDescriptions.numberOfCol, data.productConfig.tableDescriptions.hasTableHeader ); } return tempDescription; } module.exports = { processDescriptions };

/* ./src/helper/getVariants.js */
const { elementSelector } = require('./selector'); const { cleanPrice } = require('./cleanPrice'); const { elementClick } = require('./click'); const { processUrl } = require('./processUrl'); const { getStoreDomain } = require('./validate'); // Resolve images url async function fixImage(page, imageUrls, hasDomainPrefix = false, removeParamsFromUrl = false) { let domain = hasDomainPrefix ? await getStoreDomain(page.url()) : ''; return imageUrls.map((imageUrl) => { if (!imageUrl) return imageUrl; // Check if removeParamsFromUrl is not null and true if (removeParamsFromUrl !== null && removeParamsFromUrl) { imageUrl = imageUrl.split('?')[0]; } if (!imageUrl.includes(domain)) { // Add domain prefix if needed if (hasDomainPrefix && !imageUrl.startsWith('http')) { imageUrl = imageUrl.startsWith('/') ? imageUrl : '/' + imageUrl; return `${domain}${imageUrl}`; } } // Ensure the URL starts with 'https://' if (!imageUrl.startsWith('https://')) { return imageUrl.startsWith('//') ? 'https:' + imageUrl : 'https://' + imageUrl; } return imageUrl; }); } // Get Clean price async function GetCleanPrice(page, data) { const price = cleanPrice( ( await elementSelector( page, data.productConfig.price.selectors, data.productConfig.price.attribute, data.productConfig.price.regex, data.productConfig.price.groups, false, data.productConfig.price.valueToReplace ) )[0] || '' ); // if price not a number and empty if (isNaN(price)) throw ( (new Error('Price is not a number >' + price), console.log('\x1b[31m%s\x1b[0m', 'Price is not a number >' + price)) ); if (price === '') throw (new Error('Price is empty'), console.log('\x1b[31m%s\x1b[0m', 'Price is empty')); return price; } // Get option 1 async function GetOption1( page, data, option3Values, option3Id, indexOption3Id, option2Values, option2Id, indexOption2Id, arrayOptions = [] ) { if (data.productConfig.option1.selectors.length === 0) return arrayOptions; // Default values var price = ''; var sku = ''; var option1Values = []; var OutOfStockSTDIndicator = []; var quantity = 0; var options = []; var variantHandle = ''; if (data.productConfig.OutOfStockSTDIndicator.selectors.length > 0) { OutOfStockSTDIndicator = (await elementSelector(page, data.productConfig.OutOfStockSTDIndicator.selectors, null, null, null, true, [])) || []; } if (OutOfStockSTDIndicator.length === 0) { // Option 1 values option1Values = await elementSelector( page, data.productConfig.option1.selectors, data.productConfig.option1.attribute, data.productConfig.option1.regex, data.productConfig.option1.groups, true, data.productConfig.option1.valueToReplace ); option1Values.length > 0 && data.productConfig.OutOfStockSTDIndicator.selectors.length === 0 ? (option1Values = ['STD']) : option1Values; } // Click on image if (data.productConfig.clickImage.selector !== '') await elementClick(page, data.productConfig.clickImage.selector, '', data.productConfig.clickImage.delayTime); // Image srcs const imageSrcs = await fixImage( page, await elementSelector( page, data.productConfig.imageSrc.selectors, data.productConfig.imageSrc.attribute, data.productConfig.imageSrc.regex, data.productConfig.imageSrc.groups, true, data.productConfig.imageSrc.valueToReplace ), data.productConfig.imageSrc.hasDomainPrefix, data.productConfig.imageSrc.removeParamsFromUrl ); // if imageSrcs is empty if (imageSrcs.length === 0) throw new Error('Images are empty, please check your selector'); if (!data.productConfig.clickOption1.selector.length) { // get sku from url if (data.productConfig.sku.skufromUrl) { sku = processUrl( await page.url(), data.productConfig.sku.regex, data.productConfig.sku.groups, data.productConfig.sku.valueToReplace ); } else { sku = ( await elementSelector( page, data.productConfig.sku.selectors, data.productConfig.sku.attribute, data.productConfig.sku.regex, data.productConfig.sku.groups, false, data.productConfig.sku.valueToReplace ) )[0]; } // Get price price = await GetCleanPrice(page, data); // Get url after click variantHandle = page.url(); } /************************************************** * Iterate over option 1 values * **************************************************/ for (let index = 0; index < option1Values.length || index < imageSrcs.length; index++) { // Check if clickOption1 is set if (data.productConfig.clickOption1.selector.length) { // Click on option 1 await elementClick(page, data.productConfig.clickOption1.selector, option1Values[index], 0); // Get url after click variantHandle = page.url(); // Get price price = await GetCleanPrice(page, data); if (!data.productConfig.sku.skufromUrl) { sku = ( await elementSelector( page, data.productConfig.sku.selectors, data.productConfig.sku.attribute, data.productConfig.sku.regex, data.productConfig.sku.groups, false, data.productConfig.sku.valueToReplace ) )[0]; } } // options array to return options = []; if (option3Id && option2Id) { options = [ { option1: data.productConfig.option1.option1Name, value: option1Values[index] || '', }, { option2: data.productConfig.option2.option2Name, value: option2Values[indexOption2Id], }, { option3: data.productConfig.option3.option3Name, value: option3Values[indexOption3Id], }, ]; } if (option2Id) { options = [ { option1: data.productConfig.option1.option1Name, value: option1Values[index] || '', }, { option2: data.productConfig.option2.option2Name, value: option2Values[indexOption2Id], }, ]; } else if (option1Values[index]) { options = [ { option1: data.productConfig.option1.option1Name, value: option1Values[index] || '', }, ]; } if (data.productConfig.quantity.selectors.length && option1Values[index]) { quantity = ( await elementSelector( page, data.productConfig.quantity.selectors, data.productConfig.quantity.attribute, data.productConfig.quantity.regex, data.productConfig.quantity.groups, false ) )[0]; } else { quantity = 5; } // Get image src const imageSrc = imageSrcs[index] || ''; const option = { variantId: index + 1, variantHandle: variantHandle || '', price: price || '', sku: sku || '', options: options || [], quantity: quantity || 0, imageSrc: imageSrc || '', }; options.length !== 0 && option1Values.length !== 0 ? arrayOptions.push(option) : arrayOptions; } return arrayOptions; } // Get option 2 and option 1 async function GetOption2AndOption1(page, data, option3Values, option3Id, indexOption3Id, arrayOptions = []) { if (data.productConfig.option2.selectors.length === 0) return arrayOptions; // Get option 2 values const option2Values = (await elementSelector( page, data.productConfig.option2.selectors || null, data.productConfig.option2.attribute || null, data.productConfig.option2.regex || null, data.productConfig.option2.groups || [], true, data.productConfig.option2.valueToReplace || [] )) || ''; // Get option 2 IDs const option2IDs = (await elementSelector( page, data.productConfig.option2Id.selectors || null, data.productConfig.option2Id.attribute || null, data.productConfig.option2Id.regex || null, data.productConfig.option2Id.groups || [], true, data.productConfig.option2Id.valueToReplace || [] )) || ''; /************************************************** * Iterate over option 2 IDs * **************************************************/ for (let indexOption2Id = 0; indexOption2Id < option2IDs.length; indexOption2Id++) { if (data.productConfig.clickOption2.selector.length && indexOption2Id > 0) { // Click on option 2 await elementClick(page, data.productConfig.clickOption2.selector, option2IDs[indexOption2Id], 0); } arrayOptions = await GetOption1( page, data, option3Values, option3Id, indexOption3Id, option2Values, option2IDs[indexOption2Id], indexOption2Id, arrayOptions ); } return arrayOptions; } // Get option 3 and option 2 and option 1 async function GetOption3AndOption2AndOption1(page, data) { let arrayOptions = []; if (data.productConfig.option3.selectors.length === 0) return arrayOptions; // Get option 3 values const option3Values = (await elementSelector( page, data.productConfig.option3.selectors, data.productConfig.option3.attribute || null, data.productConfig.option3.regex || null, data.productConfig.option3.groups || [], true, data.productConfig.option3.valueToReplace || [] )) || ''; // Get option 3 IDs const option3IDs = await elementSelector( page, data.productConfig.option3Id.selectors, data.productConfig.option3Id.attribute || null, data.productConfig.option3Id.regex || null, data.productConfig.option3Id.groups || [], true, data.productConfig.option3Id.valueToReplace || [] ); /************************************************** * Iterate over option 3 IDs * **************************************************/ for (let indexOption3Id = 0; indexOption3Id < option3IDs.length; indexOption3Id++) { if (data.productConfig.clickOption3.selector.length && indexOption3Id > 0) { // Click on option 3 await elementClick(page, data.productConfig.clickOption3.selector, option3IDs[indexOption3Id], 0); } arrayOptions = await GetOption2AndOption1( page, data, option3Values, option3IDs[indexOption3Id], indexOption3Id, arrayOptions ); } return arrayOptions; } module.exports = { GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, };

/* ./src/helper/htmlSelector.js */
async function mainSelector(page, selector) { try { return await page.evaluate( ({ selector }) => { // Define cleanHtml function inside page.evaluate function cleanHtml(html) { const doc = new DOMParser().parseFromString(html, 'text/html'); // Define an array of tags to remove const tagsToRemove = ['button', 'video', 'source', 'style', 'img']; // Define an array of tags to exclude const excludedTags = ['table', 'tr', 'td', 'th', 'thead', 'tbody', 'tfoot']; // Remove specified tags tagsToRemove.forEach((tag) => { const elements = doc.querySelectorAll(tag); elements.forEach((el) => el.parentNode.removeChild(el)); }); // Remove comments const allNodes = doc.body.childNodes; for (let i = allNodes.length - 1; i >= 0; i--) { if (allNodes[i].nodeType === 8) { // Node type 8 is for comments allNodes[i].parentNode.removeChild(allNodes[i]); } } const allElements = doc.querySelectorAll('*'); for (let el of allElements) { // if (!excludedTags.includes(el.tagName.toLowerCase())) { // while (el.attributes.length > 0) el.removeAttribute(el.attributes[0].name); // } // Remove all attributes except for table-related elements while (el.attributes.length > 0) el.removeAttribute(el.attributes[0].name); // Remove empty elements except for table-related elements if (el.innerHTML.trim() === '' && !excludedTags.includes(el.tagName.toLowerCase())) { el.parentNode.removeChild(el); } } // Get the HTML as a string and remove tabs, line breaks, and new lines let cleanedHtml = doc.body.innerHTML; cleanedHtml = cleanedHtml.replace(/[\t\n\r]+/g, ' '); return cleanedHtml; // Return the cleaned HTML } const isXPathSelector = selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//'); let elements; if (isXPathSelector) { const result = document.evaluate(selector, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); elements = []; for (let i = 0; i < result.snapshotLength; i++) { elements.push(result.snapshotItem(i)); } } else { elements = Array.from(document.querySelectorAll(selector)); } return elements.map((el) => cleanHtml(el.outerHTML)).filter((html) => html.trim() !== ''); }, { selector } ); } catch (error) { console.log('\x1b[31m%s\x1b[0m', `Error with selector ${selector} > ${error}`); return []; } } function replaceValues(value, replacements) { replacements.forEach((replacement) => { if (replacement.value) { value = value.replace(new RegExp(replacement.value, 'gi'), replacement.replaceWith); } }); return value.trim(); } async function htmlSelector(page, selectors, queryAll, valueToReplace) { if (!Array.isArray(selectors)) { throw new Error('selectors must be an array'); } if (valueToReplace && !Array.isArray(valueToReplace)) { throw new Error('valueToReplace must be an array of replacement rules'); } let selectedValues = []; for (const selector of selectors) { const elements = await mainSelector(page, selector); if (elements.length === 0) { console.log('\x1b[90m%s\x1b[0m', `Error selector "${selector}" returned 0 elements`); continue; } for (const elementValue of elements) { let value = elementValue; if (valueToReplace) { value = replaceValues(value, valueToReplace); } if (value) selectedValues.push(value); } if (!queryAll && selectedValues.length) { break; } } return selectedValues; } module.exports = { htmlSelector };

/* ./src/helper/packages.js */
'use strict'; /* * Purpose : To load all Node.Js Packages * Package : NPM Packages * Developed By : Tishko Rasoul (tishko.rasoulgmail.com) */ const puppeteer = require('puppeteer-extra'), stealth = require('puppeteer-extra-plugin-stealth'), scrollToBottom = require('scroll-to-bottomjs'), fs = require('fs'), Xvfb = require('xvfb'), useProxy = require('puppeteer-page-proxy'), express = require('express'), router = express.Router(), cors = require('cors'), http = require('http'), compression = require('compression'), bodyParser = require('body-parser'), app = require('express')(), { v4: uuidv4 } = require('uuid'), { elementSelector } = require('./selector'), { elementClick } = require('./click'), { delay } = require('./delay'), { isValidStore, getStoreName, checkJsonValidation, validate, getStoreDomain } = require('./validate'), { blockResources } = require('./blockResources'), { cleanPrice } = require('./cleanPrice'), { GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1 } = require('./getVariants'), { htmlSelector } = require('./htmlSelector'), { processDescriptions } = require('./descriptionBuilder'), { processUrl } = require('./processUrl'); module.exports = { app, express, router, cors, http, delay, compression, uuidv4, puppeteer, bodyParser, scrollToBottom, fs, validate, Xvfb, stealth, useProxy, elementSelector, elementClick, isValidStore, blockResources, cleanPrice, GetOption3AndOption2AndOption1, GetOption2AndOption1, GetOption1, htmlSelector, processDescriptions, processUrl, getStoreName, checkJsonValidation, getStoreDomain, };

/* ./src/helper/processUrl.js */
function applyRegexAndGroups(value, regex, groups) { const matches = value.match(new RegExp(regex, 'gi')); if (!matches) return ''; return groups && groups.length > 0 ? groups.map((group) => matches[group]).join('') : matches.join(''); } function replaceValues(value, replacements) { replacements.forEach((replacement) => { if (replacement.value) { value = value.replace(new RegExp(replacement.value, 'gi'), replacement.replaceWith); } }); return value.trim(); } function processUrl(url, regex, groups, valueToReplace) { let value = regex ? applyRegexAndGroups(url, regex, groups) : url; if (valueToReplace) { value = replaceValues(value, valueToReplace); } return value; } module.exports = { processUrl };

/* ./src/helper/selector.js */
async function mainSelector(page, selector, attribute) { try { return await page.evaluate( async ({ selector, attribute }) => { // Function to decode HTML entities const decodeHtmlEntities = (text) => { return text .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&quot;/g, '"') .replace(/&39;/g, "'") .replace(/&amp;/g, '&'); }; // Check if the selector is an XPath selector const isXPathSelector = selector.startsWith('//') || selector.startsWith('(//') || selector.startsWith('((//'); let elements; if (isXPathSelector) { // Use document.evaluate for XPath selectors const result = document.evaluate(selector, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null); elements = []; for (let i = 0; i < result.snapshotLength; i++) { elements.push(result.snapshotItem(i)); } } else { // Use querySelectorAll for CSS selectors elements = Array.from(document.querySelectorAll(selector)); } // Extract attribute or text content from elements return elements.map((el) => { if (attribute) { return decodeHtmlEntities(el.getAttribute(attribute) || ''); } else { return decodeHtmlEntities(el.textContent.trim()); } }); }, { selector, attribute } ); } catch (error) { console.log('\x1b[31m%s\x1b[0m', `Error with selector ${selector} > ${error}`); return []; // Return an empty array if there's an error } } function applyRegexAndGroups(value, regex, groups) { const matches = value.match(new RegExp(regex, 'gi')); if (!matches) return ''; return groups && groups.length > 0 ? groups.map((group) => matches[group]).join('') : matches.join(''); } function replaceValues(value, replacements) { replacements.forEach((replacement) => { if (replacement.value) { value = value.replace(new RegExp(replacement.value, 'gi'), replacement.replaceWith); } }); return value.trim(); } async function elementSelector(page, selectors, attribute, regex, groups, queryAll, valueToReplace) { if (!Array.isArray(selectors)) { throw new Error('selectors must be an array'); } if (valueToReplace && !Array.isArray(valueToReplace)) { throw new Error('valueToReplace must be an array of replacement rules'); } let selectedValues = []; for (const selector of selectors) { const elements = await mainSelector(page, selector, attribute); if (elements.length === 0) { //Grey color warn console console.log('\x1b[90m%s\x1b[0m', `Error selector "${selector}" returned 0 elements`); continue; // Skip to the next selector if no elements are found } for (const elementValue of elements) { let value = regex ? applyRegexAndGroups(elementValue, regex, groups) : elementValue; if (valueToReplace) { value = replaceValues(value, valueToReplace); } if (value) selectedValues.push(value); } if (!queryAll && selectedValues.length) { break; } } //console.log('selectedValues', selectedValues); return selectedValues; } module.exports = { elementSelector };

/* ./src/helper/validate.js */
const { check, validationResult } = require('express-validator'), fs = require('fs'); function validateBody(method) { switch (method) { case 'product': { return [check('handle').notEmpty().withMessage('handle field is required').trim()]; } break; } } async function isValidStore(store) { if ( Array.from(fs.readdirSync('./src/models/data')) .map((e) => e.replace('.json', '')) .includes(store) ) return true; else return false; } async function getStoreName(handle) { var match = await handle.match( '^((http[s]?|ftp)://)?/?([^/.]+.)*?([^/.]+.[^:/s.]{1,3}(.[^:/s.]{1,2})?(:d+)?)($|/)([^#?s]+)?(.*?)?(#[w-]+)?$' ); return await match[4].replace(/\..+/g, ''); } async function getStoreDomain(handle) { var match = await handle.match( '^((http[s]?|ftp)://)?/?([^/.]+.)*?([^/.]+.[^:/s.]{1,3}(.[^:/s.]{1,2})?(:d+)?)($|/)([^#?s]+)?(.*?)?(#[w-]+)?$' ); //concat groups 1,3,4 concatGroups = (await match[1]) + (await match[3]) + (await match[4]); return await concatGroups.replace(/\/[^\/]*$/g, ''); } /* To Check Validation json using validationResult */ async function checkJsonValidation(req, res) { let errors = validationResult(req); if (!errors.isEmpty()) { return res.status(500).json({ message: errors.array()[0].msg, }); } } async function validate(req, res, next) { // get handle from request body const { handle } = req.body; // validate request body handle field validateBody('product'); /* Check Validation json using validationResult */ checkJsonValidation(req, res); // Get store name const store = await getStoreName(handle); // Check if store is supported if (!(await isValidStore(store))) { // msg red Console store name not supported console.log('\x1b[31m%s\x1b[0m', `${store} is not supported!`); return res.status(500).json({ message: `${store} is not supported!`, }); } console.log('\x1b[34m%s\x1b[0m', handle); next(); } module.exports = { validate, isValidStore, getStoreName, checkJsonValidation, getStoreDomain };

/* ./src/routes/api/v1/index.js */
'use strict'; /* * Purpose : For All Website API's Routing * Package : Router * Developed By : Tishko Rasoul (tishko.rasoul@gmail.com) */ const express = require('express'), router = express.Router(), { scrapeProduct } = require('../../../controllers/scrapeProduct'), { validate } = require('../../../helper/packages'); /* Routings */ router.post('/product', validate, scrapeProduct); router.post('/collection', validate, scrapeProduct); module.exports = router;

